# 数のプログラミングにおける表現
## 整数
Pythonでは普通に整数を入力すれば良いです。以下のコードはaという変数に整数100を代入しています。
```
a = 100
```
C言語など言語によっては型宣言が必要です。
```
int a = 100;
```
### 仕組み
コンピュータはノイズへの耐性のために0か1のみで情報を判断します。(電流の強さでより細かく分割することも精度を無視すれば可能)
私たちが普段使う数字は10進数と呼ばれるもので、23 = 2×10<sup>1</sup> + 3×10<sup>0</sup>
ですが、コンピュータは23 = 1×2<sup>4</sup> + 0×2<sup>3</sup> + 1×2<sup>2</sup> + 1×2<sup>1</sup> + 1×2<sup>0</sup>
として、電圧の有無で表現しています。
そしてAND, OR, NOT回路やNAND回路を組み合わせれば電流を使った2進数で表された四則演算を行うことができます。

## 有理数、実数
数学では別の分類ですが、これらはコンピュータでは表現方法は同じです。割り算もしくは小数で表現します。
```
b = -5/3 = -1.33333333333333
c = 1.414213562373095
```
これは、コンピュータが表せる桁数には電流のオンオフが数えられる数により限度が存在するからです。何かしらで上限をある程度は上げられますが厳密に等しい有理数や無理数は2進数で割り切れない限り不可能です。
Pythonやc言語では数学で重要なネイピア数や円周率などはあらかじめ用意されています。
```
import math
a = math.pi
e = math.e
```

## 複素数
複素数の計算は、Pythonでは虚数単位にjを用いることでそのままできます。
```
# --- 複素数の定義 ---
# 虚数単位は 'j' を使います
z1 = 3 + 4j
z2 = 1 - 2j

print(f"z1 = {z1}")
print(f"Type: {type(z1)}")  # <class 'complex'>

# --- 基本的な四則演算 ---
print(f"足し算: {z1 + z2}")
print(f"引き算: {z1 - z2}")
print(f"掛け算: {z1 * z2}")
print(f"割り算: {z1 / z2}")

# --- 属性とメソッド ---
# 実部と虚部
print(f"実部 (Real): {z1.real}")
print(f"虚部 (Imag): {z1.imag}")

# 共役複素数 (Conjugate): 3 - 4j
print(f"共役 (Conjugate): {z1.conjugate()}")

# --- 注意点 ---
# 変数を使わず純虚数を書くときは数字をつける必要があります
# x = j      # これはエラー（変数jとみなされる）
x = 1j       # これはOK
```
次にオブジェクト指向を使って複素数型を定義してみましょう
```
import math

class ComplexNumber:
    """
    複素数を表すクラス
    属性:
        real (float): 実部
        imag (float): 虚部
    """
    def __init__(self, real, imag=0.0):
        self.real = float(real)
        self.imag = float(imag)

    # --- 文字列表現 (printで表示される形) ---
    def __str__(self):
        op = "+" if self.imag >= 0 else "-"
        return f"({self.real} {op} {abs(self.imag)}i)"

    def __repr__(self):
        return self.__str__()

    # --- 演算子のオーバーロード (足し算 +) ---
    def __add__(self, other):
        # 相手がComplexNumberならそのまま計算
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real + other.real, self.imag + other.imag)
        # 相手が普通の数字(int/float)なら実部だけ足す
        elif isinstance(other, (int, float)):
            return ComplexNumber(self.real + other, self.imag)
        else:
            return NotImplemented

    # --- 逆向きの足し算 (例: 5 + z) ---
    def __radd__(self, other):
        return self.__add__(other)

    # --- 引き算 (-) ---
    def __sub__(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real - other.real, self.imag - other.imag)
        elif isinstance(other, (int, float)):
            return ComplexNumber(self.real - other, self.imag)
        else:
            return NotImplemented

    def __rsub__(self, other):
        # other - self (例: 5 - z)
        # (5 - (a+bi)) = (5-a) - bi
        if isinstance(other, (int, float)):
            return ComplexNumber(other - self.real, -self.imag)
        return NotImplemented

    # --- 掛け算 (*) ---
    def __mul__(self, other):
        if isinstance(other, ComplexNumber):
            # (a+bi)(c+di) = (ac-bd) + (ad+bc)i
            new_real = self.real * other.real - self.imag * other.imag
            new_imag = self.real * other.imag + self.imag * other.real
            return ComplexNumber(new_real, new_imag)
        elif isinstance(other, (int, float)):
            return ComplexNumber(self.real * other, self.imag * other)
        else:
            return NotImplemented

    def __rmul__(self, other):
        return self.__mul__(other)

    # --- 共役複素数 (Conjugate) ---
    def conjugate(self):
        return ComplexNumber(self.real, -self.imag)

    # --- 絶対値 (|z|) ---
    def __abs__(self):
        return math.sqrt(self.real**2 + self.imag**2)

    # --- 割り算 (/) ---
    def __truediv__(self, other):
        if isinstance(other, ComplexNumber):
            # 分母の有理化: z1/z2 = (z1 * z2_bar) / |z2|^2
            denom = other.real**2 + other.imag**2
            if denom == 0:
                raise ZeroDivisionError("複素数の0除算です")
            
            # 分子を計算 (z1 * z2_bar)
            numerator = self * other.conjugate()
            
            return ComplexNumber(numerator.real / denom, numerator.imag / denom)
            
        elif isinstance(other, (int, float)):
            if other == 0:
                raise ZeroDivisionError("0除算です")
            return ComplexNumber(self.real / other, self.imag / other)
        else:
            return NotImplemented

    # --- 等価判定 (==) ---
    def __eq__(self, other):
        if isinstance(other, ComplexNumber):
            return self.real == other.real and self.imag == other.imag
        elif isinstance(other, (int, float)):
            return self.real == other and self.imag == 0
        return False
```
