## 一次方程式
まずax+b = cx+dの係数を引数としてこの一次方程式を解く関数を作成しましょう。
```
def solve_1st_deg_equation(a,b,c,d);
    if a == c;
        if b == d;
            print("任意の複素数")
        else;
            print("解なし")
    else;
        print("x = (d - b)/ (a - c)")
        return (d - b)/ (a - c)
```

次に任意の一次方程式を解く関数をsympyを用いて作成しましょう。  
文字列の"2x+1=(3(x+1)-x)+5"などを引数にできます。
```
from sympy import symbols, solve, Eq
from sympy.parsing.sympy_parser import parse_expr, standard_transformations, implicit_multiplication_application

def solve_any_1st_deg_equation_sympy(equation_str):
    try:
        x = symbols('x')
        if "=" not in equation_str:
            return "エラー: 式に '=' が含まれていません。"
        lhs_str, rhs_str = equation_str.split("=")
        transformations = (standard_transformations + (implicit_multiplication_application,))
        
        # 左辺と右辺をパース（解析）
        lhs = parse_expr(lhs_str, transformations=transformations)
        rhs = parse_expr(rhs_str, transformations=transformations)
        
        # 方程式オブジェクトを作成 (左辺 = 右辺)
        equation = Eq(lhs, rhs)
        
        # 方程式を x について解く
        solution = solve(equation, x)
        if solution:
            return solution
        else:
            if lhs - rhs == 0:
                print("任意の複素数")
            else:
                print("解なし")

    except Exception as e:
        return f"エラーが発生しました: {e}"
```

次に外部ライブラリを使わずに作ってみましょう
```
# --- 1. 数学的な「一次式」を扱うクラス ---
class Linear:
    def __init__(self, a, b): #クラスのインスタンスを生成する
        self.a = a  # xの係数
        self.b = b  # 定数項

    def __repr__(self):
        return f"({self.a}x + {self.b})"　#リストなどに入ったオブジェクトをprintで表示するため

    # 足し算: (a1*x + b1) + (a2*x + b2)
    def __add__(self, other):
        return Linear(self.a + other.a, self.b + other.b)

    # 引き算
    def __sub__(self, other):
        return Linear(self.a - other.a, self.b - other.b)

    # 掛け算: 一次方程式なので、片方は必ず定数（a=0）である必要があります
    def __mul__(self, other):
        if self.a != 0 and other.a != 0:
            raise ValueError("非線形エラー: x同士の掛け算はできません")
        # (ax + b) * (cx + d) ただしどちらかの係数は0
        # 展開すると: ac*x^2 + (ad+bc)x + bd
        # x^2の項(ac)が0になるはず
        new_a = self.a * other.b + self.b * other.a
        new_b = self.b * other.b
        return Linear(new_a, new_b)

    # 割り算: 定数での割り算のみ対応
    def __truediv__(self, other):
        if other.a != 0:
            raise ValueError("非線形エラー: xでの割り算は一次方程式ではありません")
        return Linear(self.a / other.b, self.b / other.b)

# --- 2. 字句解析（文字列をトークンリストにする） ---
def tokenize(expr):
    tokens = []
    i = 0
    while i < len(expr):
        char = expr[i]
        
        if char.isspace(): #空白ならスキップ
            i += 1
            continue
        
        if char.isdigit() or char == '.':
            # 数値の読み取り（複数桁や小数に対応）
            num_str = char
            i += 1
            while i < len(expr) and (expr[i].isdigit() or expr[i] == '.'):
                num_str += expr[i]
                i += 1
            tokens.append(('NUM', float(num_str)))
            continue
            
        if char == 'x':
            tokens.append(('VAR', 'x'))
        elif char in "+-*/()":
            tokens.append(('OP', char))
        else:
            raise ValueError(f"不明な文字: {char}")
        i += 1
    return tokens

# --- 3. 構文解析（再帰下降パーサー） ---
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0

    def peek(self):
        return self.tokens[self.pos] if self.pos < len(self.tokens) else None

    def consume(self):
        token = self.tokens[self.pos]
        self.pos += 1
        return token

    # 式 (Expression): Term + Term ...
    def parse_expression(self):
        left = self.parse_term()
        
        while True:
            token = self.peek()
            if token and token[0] == 'OP' and token[1] in ('+', '-'):
                op = self.consume()[1]
                right = self.parse_term()
                if op == '+':
                    left = left + right
                else:
                    left = left - right
            else:
                break
        return left

    # 項 (Term): Factor * Factor ...
    def parse_term(self):
        left = self.parse_factor()
        
        while True:
            token = self.peek()
            if token and token[0] == 'OP' and token[1] in ('*', '/'):
                op = self.consume()[1]
                right = self.parse_factor()
                if op == '*':
                    left = left * right
                else:
                    left = left / right
            else:
                break
        return left

    # 因子 (Factor): Number, x, (Expression), or -Factor
    def parse_factor(self):
        token = self.peek()
        
        # 単項マイナス（例: -x, -5）
        if token and token[0] == 'OP' and token[1] == '-':
            self.consume()
            operand = self.parse_factor()
            # -1 を掛けるのと同じ
            return Linear(0, -1) * operand

        if token[0] == 'NUM':
            self.consume()
            return Linear(0, token[1]) # 数値は a=0, b=値
        
        elif token[0] == 'VAR':
            self.consume()
            return Linear(1, 0) # x は a=1, b=0
        
        elif token[0] == 'OP' and token[1] == '(':
            self.consume()
            expr = self.parse_expression()
            if self.peek()[1] != ')':
                raise ValueError("カッコが閉じられていません")
            self.consume()
            return expr
            
        else:
            raise ValueError("数式の構文エラー")

# --- 4. メインのソルバー関数 ---
def solve_linear_equation_no_eval(equation_str):
    try:
        if "=" not in equation_str:
            return "エラー: '=' がありません"
            
        lhs_str, rhs_str = equation_str.split("=")
        
        # 左辺をパース -> ax + b
        lhs_tokens = tokenize(lhs_str)
        lhs_parser = Parser(lhs_tokens)
        lhs_val = lhs_parser.parse_expression()
        
        # 右辺をパース -> cx + d
        rhs_tokens = tokenize(rhs_str)
        rhs_parser = Parser(rhs_tokens)
        rhs_val = rhs_parser.parse_expression()
        
        # 方程式を解く
        # lhs_val.a * x + lhs_val.b = rhs_val.a * x + rhs_val.b
        # (lhs_a - rhs_a) * x = rhs_b - lhs_b
        
        a = lhs_val.a - rhs_val.a
        b = rhs_val.b - lhs_val.b
        
        if abs(a) < 1e-10: # 浮動小数点の誤差考慮
            if abs(b) < 1e-10:
                return "不定 (任意の数)"
            else:
                return "不能 (解なし)"
                
        x = b / a
        
        # 整数できれいに割り切れる場合はintにする
        if x.is_integer():
            return int(x)
        return x

    except Exception as e:
        return f"エラー: {e}"
```
